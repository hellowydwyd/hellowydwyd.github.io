

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="YuDong Wang">
  <meta name="keywords" content="编程,技术,开发,博客,JavaScript,Python,Web开发">
  
    <meta name="description" content="进程同步是多道程序环境下协调进程并发执行的核心机制。引入进程后，虽能通过并发提升资源利用率和系统吞吐量，但进程对共享资源的无序争夺会导致执行结果不可再现。进程同步的本质是通过特定规则协调进程执行次序，确保共享资源有序访问与进程间高效协作，使程序执行具备可再现性。 一、进程同步的基本概念与制约关系 1. 进程同步的核心任务 对多个相关进程的执行次序进行协调，解决“并发导致的资源争夺与协作混乱”问题，">
<meta property="og:type" content="article">
<meta property="og:title" content="进程同步总结">
<meta property="og:url" content="https://hellowydwyd.github.io/2025/10/16/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Wydcoder&#39;s Tech Blog">
<meta property="og:description" content="进程同步是多道程序环境下协调进程并发执行的核心机制。引入进程后，虽能通过并发提升资源利用率和系统吞吐量，但进程对共享资源的无序争夺会导致执行结果不可再现。进程同步的本质是通过特定规则协调进程执行次序，确保共享资源有序访问与进程间高效协作，使程序执行具备可再现性。 一、进程同步的基本概念与制约关系 1. 进程同步的核心任务 对多个相关进程的执行次序进行协调，解决“并发导致的资源争夺与协作混乱”问题，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-10-16T06:27:40.000Z">
<meta property="article:modified_time" content="2025-10-16T06:28:09.947Z">
<meta property="article:author" content="YuDong Wang">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>进程同步总结 - Wydcoder&#39;s Tech Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"hellowydwyd.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Wydcoder's Tech Blog" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Wydcoder&#39;s Tech Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/images/about-bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="进程同步总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        YuDong Wang
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-10-16 14:27" pubdate>
          星期四, 十月 16日 2025, 2:27 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          4.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          39 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">进程同步总结</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    <!-- compatible with older versions-->
                    本文最后更新于：2025年10月16日 下午
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>进程同步是多道程序环境下协调进程并发执行的核心机制。引入进程后，虽能通过并发提升资源利用率和系统吞吐量，但进程对共享资源的无序争夺会导致执行结果不可再现。进程同步的本质是通过特定规则协调进程执行次序，确保共享资源有序访问与进程间高效协作，使程序执行具备可再现性。</p>
<h2 id="一、进程同步的基本概念与制约关系">一、进程同步的基本概念与制约关系</h2>
<h3 id="1-进程同步的核心任务">1. 进程同步的核心任务</h3>
<p>对多个相关进程的执行次序进行协调，解决“并发导致的资源争夺与协作混乱”问题，具体包括：</p>
<ul>
<li>确保进程按规则共享系统资源（如打印机、共享变量）；</li>
<li>实现进程间的有效合作（如“司机-售票员”进程的协同操作）；</li>
<li>消除并发执行的不可再现性，保证每次执行结果一致。</li>
</ul>
<h3 id="2-进程间的两种制约关系">2. 进程间的两种制约关系</h3>
<p>进程并发执行时，因资源共享或任务协作产生两种典型制约关系，均需同步机制协调：</p>
<h4 id="（1）间接相互制约关系（资源共享导致）">（1）间接相互制约关系（资源共享导致）</h4>
<ul>
<li><strong>产生原因</strong>：多个进程共享同一临界资源（如打印机、共享内存），需通过互斥方式访问，避免资源状态被无序修改。</li>
<li><strong>示例</strong>：进程A和进程B均需使用打印机，若A正在打印（占用打印机），B必须等待A释放后才能使用。</li>
<li><strong>本质</strong>：进程间无直接通信，仅因共享资源而间接相互限制。</li>
</ul>
<h4 id="（2）直接相互制约关系（任务协作导致）">（2）直接相互制约关系（任务协作导致）</h4>
<ul>
<li><strong>产生原因</strong>：多个进程为完成同一任务需协同工作，一个进程的执行依赖另一个进程的结果（如“生产者-消费者”进程，生产者生产产品后消费者才能消费）。</li>
<li><strong>示例</strong>：司机进程（P1）需在售票员进程（P2）关门后才能启动车辆，P2需在P1到站停车后才能开门，二者执行顺序直接关联。</li>
<li><strong>本质</strong>：进程间存在明确的依赖关系，需通过信号或消息传递同步执行节奏。</li>
</ul>
<h2 id="二、临界资源与临界区">二、临界资源与临界区</h2>
<h3 id="1-临界资源（Critical-Resource）">1. 临界资源（Critical Resource）</h3>
<ul>
<li><strong>定义</strong>：一次仅允许一个进程访问的资源，包括硬件资源（如打印机、磁带机）和软件资源（如共享变量、数据库记录）。</li>
<li><strong>核心特性</strong>：排他性——若多个进程同时访问，会导致资源状态混乱或执行结果错误。</li>
<li><strong>管理原则</strong>：进程对临界资源的访问必须互斥，即一个进程访问时，其他进程需等待。</li>
</ul>
<h3 id="2-临界区（Critical-Section）">2. 临界区（Critical Section）</h3>
<ul>
<li><strong>定义</strong>：每个进程中直接访问临界资源的那段代码，是进程同步的核心控制对象。</li>
<li><strong>进程访问临界区的标准结构</strong>：为确保互斥，进程访问临界资源需遵循“进入区→临界区→退出区→剩余区”的流程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while(TRUE)&#123;<br>    进入区（Entry Section）：检查临界资源是否可用，若不可用则阻塞，避免“忙等”；<br>    临界区（Critical Section）：访问临界资源的核心代码，执行时独占资源；<br>    退出区（Exit Section）：释放临界资源，唤醒等待的进程；<br>    剩余区（Remainder Section）：与临界资源无关的其他代码；<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>关键问题</strong>：若多个进程并发执行时，临界区代码未加控制，会导致共享资源操作异常（如共享变量计算错误）。</li>
</ul>
<h4 id="示例：临界区代码并发执行的问题">示例：临界区代码并发执行的问题</h4>
<p>以“生产者-消费者”问题中共享变量<code>counter</code>（记录缓冲池产品数量）为例：</p>
<ul>
<li>生产者对<code>counter</code>的加1操作（<code>counter++</code>）对应机器指令：<code>register1=counter; register1=register1+1; counter=register1;</code></li>
<li>消费者对<code>counter</code>的减1操作（<code>counter--</code>）对应机器指令：<code>register2=counter; register2=register2-1; counter=register2;</code></li>
<li>若二者并发执行，可能出现指令交错（如生产者读取<code>counter=5</code>后，消费者也读取<code>counter=5</code>，最终<code>counter</code>可能被改为4而非5），导致<code>counter</code>值错误，进而引发缓冲池溢出或空取问题。</li>
</ul>
<h2 id="三、同步机制的四大规则">三、同步机制的四大规则</h2>
<p>为确保临界区的安全访问，任何同步机制都需遵循以下4条核心规则，缺一不可：</p>
<table>
<thead>
<tr>
<th>规则名称</th>
<th>核心要求</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>空闲让进</strong></td>
<td>若临界区无进程执行，需访问临界区的进程应立即进入</td>
<td>避免资源空闲，提高资源利用率</td>
</tr>
<tr>
<td><strong>忙则等待</strong></td>
<td>若临界区已有进程执行，其他请求访问的进程必须等待</td>
<td>保证临界资源的互斥访问，防止冲突</td>
</tr>
<tr>
<td><strong>有限等待</strong></td>
<td>请求访问临界区的进程需在有限时间内进入，不得“永久等待”</td>
<td>避免“死等”（饥饿），确保进程公平性</td>
</tr>
<tr>
<td><strong>让权等待</strong></td>
<td>进程无法进入临界区时，需立即释放CPU（转为阻塞状态），而非“忙等”</td>
<td>避免CPU资源浪费，提高系统吞吐量</td>
</tr>
</tbody>
</table>
<h2 id="四、进程同步的实现机制">四、进程同步的实现机制</h2>
<p>根据实现层面的不同，同步机制分为<strong>硬件同步机制</strong>和<strong>软件同步机制</strong>（信号量、管程），其中硬件机制是基础，软件机制是主流应用方式。</p>
<h3 id="1-硬件同步机制">1. 硬件同步机制</h3>
<p>利用硬件指令的原子性（不可中断）实现互斥，无需操作系统内核干预，但存在局限性，适用于简单场景。</p>
<h4 id="（1）关中断（Disable-Interrupts）">（1）关中断（Disable Interrupts）</h4>
<ul>
<li><strong>实现逻辑</strong>：进程进入临界区前关闭CPU中断，执行完临界区代码后再打开中断。关闭中断期间，CPU不响应任何中断请求，不会发生进程切换，确保临界区代码连续执行。</li>
<li><strong>优点</strong>：实现最简单，无需复杂数据结构。</li>
<li><strong>缺点</strong>：
<ol>
<li>滥用关中断可能导致系统异常（如忽略硬件故障中断）；</li>
<li>关中断时间过长会降低CPU利用率，限制并发能力；</li>
<li>不适用于多CPU系统（一个CPU关中断无法阻止其他CPU访问临界区）。</li>
</ol>
</li>
</ul>
<h4 id="（2）Test-and-Set（TS）指令">（2）Test-and-Set（TS）指令</h4>
<ul>
<li><strong>指令功能</strong>：原子性完成“测试锁状态”和“设置锁为占用”操作，返回锁的原始状态。指令定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">boolean <span class="hljs-title function_">TS</span><span class="hljs-params">(boolean *lock)</span>&#123; <br>    boolean old = *lock;  <span class="hljs-comment">// 保存锁的原始状态</span><br>    *lock = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 将锁设为“占用”</span><br>    <span class="hljs-keyword">return</span> old;           <span class="hljs-comment">// 返回原始状态（true表示锁已占用，false表示空闲）</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>实现互斥的逻辑</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-keyword">while</span>(TS(&amp;lock));  <span class="hljs-comment">// 循环测试锁，直到锁空闲（TS返回false）</span><br>    临界区;             <span class="hljs-comment">// 锁空闲，进入临界区</span><br>    lock = <span class="hljs-literal">false</span>;       <span class="hljs-comment">// 退出临界区，释放锁</span><br>    剩余区;<br>&#125;<span class="hljs-keyword">while</span>(TRUE);<br></code></pre></td></tr></table></figure>
</li>
<li><strong>优点</strong>：支持多CPU系统，实现简单。</li>
<li><strong>缺点</strong>：未遵循“让权等待”规则，进程等待时处于“忙等”状态，浪费CPU资源。</li>
</ul>
<h4 id="（3）Swap指令（Exchange指令）">（3）Swap指令（Exchange指令）</h4>
<ul>
<li><strong>指令功能</strong>：原子性交换两个变量的值，确保交换过程不被中断。指令定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span><span class="hljs-params">(boolean *a, boolean *b)</span>&#123; <br>    boolean temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>实现互斥的逻辑</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">do</span>&#123;<br>    boolean key = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">do</span>&#123;<br>        Swap(&amp;lock, &amp;key);  <span class="hljs-comment">// 交换lock和key的值，测试锁状态</span><br>    &#125;<span class="hljs-keyword">while</span>(key != <span class="hljs-literal">false</span>);   <span class="hljs-comment">// key为false表示锁空闲，退出循环</span><br>    临界区;                 <span class="hljs-comment">// 进入临界区</span><br>    lock = <span class="hljs-literal">false</span>;           <span class="hljs-comment">// 释放锁</span><br>    剩余区;<br>&#125;<span class="hljs-keyword">while</span>(TRUE);<br></code></pre></td></tr></table></figure>
</li>
<li><strong>优缺点</strong>：与TS指令类似，支持多CPU但存在“忙等”问题。</li>
</ul>
<h3 id="2-信号量机制（软件同步机制）">2. 信号量机制（软件同步机制）</h3>
<p>1965年由荷兰学者Dijkstra提出，是目前应用最广泛的同步机制之一。信号量是一个抽象数据结构，通过<code>P</code>（<code>wait</code>）、<code>V</code>（<code>signal</code>）两个原子操作控制资源访问，可实现互斥与同步。</p>
<h4 id="（1）信号量的核心属性">（1）信号量的核心属性</h4>
<ul>
<li><strong>本质</strong>：一个记录型数据结构，包含“资源数量”和“等待进程队列”（仅记录型信号量有队列）；</li>
<li><strong>值的含义</strong>：信号量的值与资源使用状态相关，仅能通过<code>P</code>、<code>V</code>操作修改；</li>
<li><strong>初始化</strong>：初值需在创建时设置一次，且初值非负（资源数量或同步标记）。</li>
</ul>
<h4 id="（2）信号量的分类与实现">（2）信号量的分类与实现</h4>
<p>根据功能和结构，信号量分为<strong>整型信号量</strong>、<strong>记录型信号量</strong>、<strong>AND型信号量</strong>和<strong>信号量集</strong>，分别适用于不同场景：</p>
<h5 id="①-整型信号量">① 整型信号量</h5>
<ul>
<li><strong>定义</strong>：信号量为整型变量<code>S</code>，仅通过<code>P</code>、<code>V</code>原子操作访问：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// P操作（申请资源）：若资源不足则“忙等”</span><br>wait(S)&#123; <br>    <span class="hljs-keyword">while</span>(S &lt;= <span class="hljs-number">0</span>);  <span class="hljs-comment">// 资源不足时循环等待（忙等）</span><br>    S--;            <span class="hljs-comment">// 申请成功，资源数量减1</span><br>&#125;<br><span class="hljs-comment">// V操作（释放资源）：资源数量加1</span><br>signal(S)&#123; <br>    S++;            <span class="hljs-comment">// 释放资源，资源数量加1</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>优点</strong>：实现简单，适用于单CPU系统。</li>
<li><strong>缺点</strong>：未遵循“让权等待”规则，进程等待时“忙等”，浪费CPU资源。</li>
</ul>
<h5 id="②-记录型信号量（解决“忙等”问题）">② 记录型信号量（解决“忙等”问题）</h5>
<ul>
<li><strong>定义</strong>：在整型信号量基础上增加“等待进程队列”，当资源不足时，进程进入队列阻塞（释放CPU），遵循“让权等待”规则。结构定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> value;          <span class="hljs-comment">// 资源数量（value&gt;=0：可用资源数；value&lt;0：等待进程数的绝对值）</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span> *<span class="hljs-title">list</span>;</span>   <span class="hljs-comment">// 等待该信号量的进程队列（PCB链表）</span><br>&#125;semaphore;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>P、V操作实现</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// P操作（申请资源）</span><br>wait(semaphore *S)&#123; <br>    S-&gt;value--;                <span class="hljs-comment">// 申请资源，资源数减1</span><br>    <span class="hljs-keyword">if</span>(S-&gt;value &lt; <span class="hljs-number">0</span>)&#123;          <span class="hljs-comment">// 资源不足，进程阻塞</span><br>        block(S-&gt;<span class="hljs-built_in">list</span>);        <span class="hljs-comment">// 将当前进程插入等待队列，释放CPU</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// V操作（释放资源）</span><br>signal(semaphore *S)&#123; <br>    S-&gt;value++;                <span class="hljs-comment">// 释放资源，资源数加1</span><br>    <span class="hljs-keyword">if</span>(S-&gt;value &lt;= <span class="hljs-number">0</span>)&#123;         <span class="hljs-comment">// 存在等待进程</span><br>        wakeup(S-&gt;<span class="hljs-built_in">list</span>);       <span class="hljs-comment">// 唤醒等待队列的队首进程，插入就绪队列</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>核心优势</strong>：无“忙等”，兼顾资源利用率与公平性，是目前主流的信号量形式。</li>
<li><strong>典型应用</strong>：
<ul>
<li>互斥信号量：初值为1，用于实现临界资源互斥访问（如<code>mutex=1</code>，<code>P(mutex)</code>进入临界区，<code>V(mutex)</code>退出）；</li>
<li>资源信号量：初值为资源总数（如缓冲池空缓冲区数<code>empty=n</code>），用于同步资源访问；</li>
<li>同步信号量：初值为0，用于实现进程间前趋关系（如进程A执行完<code>S1</code>后，通过<code>V(S)</code>唤醒进程B执行<code>S2</code>）。</li>
</ul>
</li>
</ul>
<h5 id="③-AND型信号量（解决多资源申请死锁）">③ AND型信号量（解决多资源申请死锁）</h5>
<ul>
<li><strong>背景</strong>：当进程需同时申请多个临界资源（如“哲学家进餐”问题中需同时拿两根筷子）时，若按顺序申请可能导致死锁（如每个哲学家都拿左筷子，再等右筷子）。</li>
<li><strong>核心思想</strong>：采用“原子操作”一次性申请所有所需资源，要么全部分配，要么一个不分配，避免部分资源占用导致的死锁。</li>
<li><strong>操作定义</strong>：
<ul>
<li><code>Swait(S1, S2, ..., Sn)</code>：同时申请<code>S1~Sn</code>资源，所有资源可用时才分配；</li>
<li><code>Ssignal(S1, S2, ..., Sn)</code>：同时释放<code>S1~Sn</code>资源，唤醒等待进程。</li>
</ul>
</li>
<li><strong>示例</strong>：哲学家申请筷子时，通过<code>Swait(chopstick[i], chopstick[(i+1)%5])</code>同时申请左右筷子，避免死锁。</li>
</ul>
<h5 id="④-信号量集（批量资源申请）">④ 信号量集（批量资源申请）</h5>
<ul>
<li><strong>背景</strong>：记录型信号量每次仅能申请1个资源，若需批量申请（如一次申请3个缓冲区），需多次执行<code>P</code>操作，效率低且可能引发死锁。</li>
<li><strong>核心思想</strong>：支持一次申请多个资源，并可设置“资源分配下限”（不足下限不分配），操作定义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Swait(S1, t1, d1, ..., Sn, tn, dn)：<br>- 对每个信号量Si，若Si &gt;= ti（ti为分配下限），则分配di个资源（Si = Si - di）；<br>- 否则，进程阻塞。<br>Ssignal(S1, d1, ..., Sn, dn)：<br>- 对每个信号量Si，释放di个资源（Si = Si + di），唤醒等待进程。<br></code></pre></td></tr></table></figure>
</li>
<li><strong>特殊场景</strong>：
<ul>
<li><code>Swait(S, d, d)</code>：一次申请d个资源，不足d个则等待；</li>
<li><code>Swait(S, 1, 1)</code>：等同于记录型信号量（互斥或单个资源申请）；</li>
<li><code>Swait(S, 1, 0)</code>：仅测试资源状态（S&gt;=1时允许进入，S=0时禁止），可作为“可控开关”。</li>
</ul>
</li>
</ul>
<h4 id="（3）信号量的典型应用">（3）信号量的典型应用</h4>
<p>信号量可灵活实现<strong>进程互斥</strong>、<strong>进程同步（前趋关系）</strong> 和<strong>复杂协作场景</strong>，以下为常见应用案例：</p>
<h5 id="①-实现进程互斥">① 实现进程互斥</h5>
<ul>
<li><strong>逻辑</strong>：为临界资源设置互斥信号量<code>mutex</code>（初值1），进程进入临界区前执行<code>P(mutex)</code>（申请资源），退出时执行<code>V(mutex)</code>（释放资源）。</li>
<li><strong>示例</strong>：两个进程PA、PB互斥访问打印机：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 互斥信号量，初值1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PA</span><span class="hljs-params">()</span>&#123; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(mutex);    <span class="hljs-comment">// 申请打印机</span><br>        临界区（使用打印机）;<br>        V(mutex);    <span class="hljs-comment">// 释放打印机</span><br>        剩余区;<br>    &#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">PB</span><span class="hljs-params">()</span>&#123; <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(mutex);    <span class="hljs-comment">// 申请打印机</span><br>        临界区（使用打印机）;<br>        V(mutex);    <span class="hljs-comment">// 释放打印机</span><br>        剩余区;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><strong>注意</strong>：<code>P</code>、<code>V</code>操作必须成对出现，缺<code>P</code>会导致互斥失效，缺<code>V</code>会导致资源永久占用。</li>
</ul>
<h5 id="②-实现进程前趋关系">② 实现进程前趋关系</h5>
<ul>
<li><strong>逻辑</strong>：为每个前趋关系设置同步信号量（初值0），前趋操作执行完后<code>V</code>操作（唤醒后续进程），后续操作执行前<code>P</code>操作（等待前趋完成）。</li>
<li><strong>示例</strong>：进程P1的S1执行后，P2的S2和P3的S3才能执行：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 同步信号量，初值0</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">P1</span><span class="hljs-params">()</span>&#123; <br>    S1; <br>    V(a);  <span class="hljs-comment">// S1完成，唤醒P2</span><br>    V(b);  <span class="hljs-comment">// S1完成，唤醒P3</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P2</span><span class="hljs-params">()</span>&#123; <br>    P(a);  <span class="hljs-comment">// 等待S1完成</span><br>    S2; <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">P3</span><span class="hljs-params">()</span>&#123; <br>    P(b);  <span class="hljs-comment">// 等待S1完成</span><br>    S3; <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="③-案例1：过独木桥问题">③ 案例1：过独木桥问题</h5>
<ul>
<li><strong>需求</strong>：同一方向行人可连续过桥，反向行人需等待当前方向无人后才能过桥。</li>
<li><strong>实现</strong>：设置互斥信号量<code>mutex</code>（控制桥的独占）、方向计数信号量<code>leftm</code>/<code>rightm</code>（保护方向计数器），通过计数器判断是否需申请桥资源：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>, leftm = <span class="hljs-number">1</span>, rightm = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> countleft = <span class="hljs-number">0</span>, countright = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 左右方向过桥人数</span><br><span class="hljs-comment">// 左→右过桥</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">leftToRight</span><span class="hljs-params">()</span>&#123; <br>    P(leftm);                <span class="hljs-comment">// 保护countleft</span><br>    <span class="hljs-keyword">if</span>(countleft == <span class="hljs-number">0</span>)       <span class="hljs-comment">// 第一个左→右行人，申请桥</span><br>        P(mutex);<br>    countleft++;             <span class="hljs-comment">// 左→右人数加1</span><br>    V(leftm);                <span class="hljs-comment">// 释放countleft</span><br>    <br>    过桥;                    <span class="hljs-comment">// 临界区</span><br>    <br>    P(leftm);                <span class="hljs-comment">// 保护countleft</span><br>    countleft--;             <span class="hljs-comment">// 左→右人数减1</span><br>    <span class="hljs-keyword">if</span>(countleft == <span class="hljs-number">0</span>)       <span class="hljs-comment">// 最后一个左→右行人，释放桥</span><br>        V(mutex);<br>    V(leftm);                <span class="hljs-comment">// 释放countleft</span><br>&#125;<br><span class="hljs-comment">// 右→左过桥逻辑类似，操作countright和rightm</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="④-案例2：父子四人水果问题">④ 案例2：父子四人水果问题</h5>
<ul>
<li><strong>需求</strong>：父亲放苹果、母亲放桔子，儿子吃桔子、女儿吃苹果，盘子仅能放1个水果。</li>
<li><strong>实现</strong>：设置信号量<code>empty</code>（盘子空，初值1）、<code>apple</code>（苹果数量，初值0）、<code>orange</code>（桔子数量，初值0）、<code>mutex</code>（保护盘子操作）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">semaphore mutex = <span class="hljs-number">1</span>, apple = <span class="hljs-number">0</span>, orange = <span class="hljs-number">0</span>, empty = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 父亲放苹果</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">father</span><span class="hljs-params">()</span>&#123; <br>    P(empty);    <span class="hljs-comment">// 申请空盘子</span><br>    P(mutex);    <span class="hljs-comment">// 保护盘子操作</span><br>    放苹果;<br>    V(mutex);    <span class="hljs-comment">// 释放盘子</span><br>    V(apple);    <span class="hljs-comment">// 通知女儿有苹果</span><br>&#125;<br><span class="hljs-comment">// 母亲放桔子（类似父亲，操作empty和orange）</span><br><span class="hljs-comment">// 女儿吃苹果（P(apple)申请苹果，V(empty)释放盘子）</span><br><span class="hljs-comment">// 儿子吃桔子（类似女儿，操作orange和empty）</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-管程机制（封装式同步机制）">3. 管程机制（封装式同步机制）</h3>
<p>信号量机制需在每个进程中手动编写<code>P</code>、<code>V</code>操作，同步逻辑分散且易出错（如<code>P</code>、<code>V</code>顺序颠倒）。管程机制通过“封装共享资源和操作”，实现同步逻辑的集中管理，确保每次仅一个进程进入管程，简化同步实现。</p>
<h4 id="（1）管程的定义与结构">（1）管程的定义与结构</h4>
<ul>
<li><strong>定义</strong>：管程是一个抽象数据类型，包含“共享数据结构”、“操作共享数据的过程”、“条件变量”和“初始化代码”，进程需通过管程提供的过程访问共享资源。</li>
<li><strong>核心特性</strong>：<strong>互斥性</strong>——管程确保每次仅一个进程执行其内部过程，无需进程手动实现互斥；<strong>同步性</strong>——通过条件变量实现进程间的协作等待与唤醒。</li>
<li><strong>结构组成</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Monitor 管程名&#123;<br>    共享变量声明;          // 管程管理的共享资源（如缓冲池、计数器）<br>    条件变量声明;          // 用于进程同步的条件变量（如notfull、notempty）<br>public:<br>    过程1(参数)&#123; ... &#125;     // 访问共享资源的过程（如put、get）<br>    过程2(参数)&#123; ... &#125;     // 访问共享资源的过程<br>    ...<br>    初始化代码;            // 初始化共享变量和条件变量<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="（2）条件变量（管程中的同步工具）">（2）条件变量（管程中的同步工具）</h4>
<p>管程通过条件变量实现进程间的同步等待与唤醒，条件变量仅能在管程内部使用，提供<code>wait</code>和<code>signal</code>两个操作：</p>
<ul>
<li><strong>条件变量的作用</strong>：当进程通过管程申请资源失败时，通过<code>wait</code>进入条件队列阻塞（释放管程）；当资源可用时，其他进程通过<code>signal</code>唤醒阻塞进程。</li>
<li><strong>核心操作</strong>：
<ul>
<li><code>x.wait()</code>：当前进程因<code>x</code>条件阻塞，插入<code>x</code>的等待队列，释放管程，允许其他进程进入；</li>
<li><code>x.signal()</code>：当前进程触发<code>x</code>条件，唤醒<code>x</code>等待队列的一个进程（若队列非空）；若唤醒后存在进程竞争，需按规则处理（如唤醒进程优先执行或当前进程继续执行）。</li>
</ul>
</li>
</ul>
<h4 id="（3）管程的优势">（3）管程的优势</h4>
<ul>
<li><strong>封装性</strong>：同步逻辑集中在管程内部，进程无需关注细节，降低编程复杂度；</li>
<li><strong>安全性</strong>：管程自动实现互斥，避免<code>P</code>、<code>V</code>操作遗漏或顺序错误导致的同步问题；</li>
<li><strong>可维护性</strong>：同步逻辑修改仅需调整管程内部，无需修改所有相关进程。</li>
</ul>
<h2 id="五、核心总结">五、核心总结</h2>
<p>进程同步的本质是解决“并发导致的资源争夺与协作混乱”，其核心逻辑可归纳为：</p>
<ol>
<li><strong>识别临界资源与临界区</strong>：明确需互斥访问的资源及对应代码段，是同步设计的基础；</li>
<li><strong>选择合适的同步机制</strong>：硬件机制适用于简单场景，信号量机制灵活通用（互斥、同步、多资源），管程机制适用于复杂共享资源管理；</li>
<li><strong>遵循同步规则</strong>：确保同步机制满足“空闲让进、忙则等待、有限等待、让权等待”，兼顾效率与公平性；</li>
<li><strong>典型应用场景</strong>：通过信号量或管程可解决“互斥访问”“前趋关系”“多资源协作”等问题，需结合具体需求设计同步逻辑（如“生产者-消费者”“哲学家进餐”等经典问题）。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="print-no-link">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>进程同步总结</div>
      <div>https://hellowydwyd.github.io/2025/10/16/进程同步总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>YuDong Wang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年10月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/10/16/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="进程控制">
                        <span class="hidden-mobile">进程控制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'hellowydwyd/hellowydwyd.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
